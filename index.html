<!DOCTYPE html>
<html lang="bn">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GMSENG TRANSLATOR - Dark Mode</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Bengali:wght@400;500;700&display=swap" rel="stylesheet">

  <style>
    body {
      font-family: 'Noto Sans Bengali', sans-serif;
      background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
      background-size: 300% 300%;
      animation: bgMove 12s ease infinite;
      min-height: 100vh;
      color: #e2e8f0;
    }
    @keyframes bgMove {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    .glass-card {
      backdrop-filter: blur(14px) saturate(160%);
      -webkit-backdrop-filter: blur(14px) saturate(160%);
      background-color: rgba(17, 25, 40, 0.65);
      border-radius: 1.5rem;
      border: 1px solid rgba(255, 255, 255, 0.15);
      box-shadow: 0 8px 32px rgba(0,0,0,0.35);
      animation: fadeIn 1.2s ease-in-out;
    }

    .btn-translate {
      background: linear-gradient(135deg, #00c6ff, #0072ff);
      transition: all 0.4s ease;
      position: relative;
      overflow: hidden;
    }
    .btn-translate::after {
      content: "";
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(255,255,255,0.3) 10%, transparent 40%);
      transform: scale(0);
      transition: transform 0.5s ease;
    }
    .btn-translate:hover::after {
      transform: scale(1);
    }
    .btn-translate:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 10px 25px rgba(0,0,0,0.45);
    }

    .output-box {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 1rem;
      padding: 1.5rem;
      min-height: 160px;
      color: #f8fafc;
      line-height: 1.6;
      font-size: 1rem;
      box-shadow: inset 0 2px 6px rgba(0,0,0,0.3);
      transition: all 0.3s ease;
    }
    .output-box:hover {
      border-color: rgba(255,255,255,0.35);
      transform: scale(1.01);
    }

    .text-input, .select-input {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 1rem;
      padding: 1rem;
      color: #f8fafc;
      transition: 0.3s ease;
    }
    .text-input::placeholder {
      color: #94a3b8;
    }
    .select-input option {
      color: #000;
    }
    .text-input:focus, .select-input:focus {
      border-color: #00c6ff;
      outline: none;
      box-shadow: 0 0 10px rgba(0,198,255,0.5);
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
  </style>
</head>
<body class="flex items-center justify-center p-6">

  <div class="w-full max-w-5xl glass-card p-10">

    <!-- Header -->
    <header class="text-center mb-10">
      <h1 class="text-4xl font-extrabold text-white drop-shadow-lg">üåô ‡¶ï‡ßã‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ‡¶® ‚Üî ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ</h1>
      <p class="text-gray-300 mt-3 text-lg tracking-wide">Welcome to GMSENG Translator</p>
    </header>

    <!-- Main -->
    <main>
      <!-- Language Mode -->
      <div class="mb-6">
        <label for="language-select" class="block text-lg font-semibold text-gray-200 mb-2">‡¶Ö‡¶®‡ßÅ‡¶¨‡¶æ‡¶¶ ‡¶Æ‡ßã‡¶°:</label>
        <select id="language-select" class="w-full select-input">
          <option value="ko-bn">‡¶ï‡ßã‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ‡¶® ‡¶•‡ßá‡¶ï‡ßá ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ</option>
          <option value="bn-ko">‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ ‡¶•‡ßá‡¶ï‡ßá ‡¶ï‡ßã‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ‡¶®</option>
        </select>
      </div>

      <!-- Input Text -->
      <div class="mb-6">
        <label id="input-label" for="input-text" class="block text-lg font-semibold text-gray-200 mb-2">‡¶ï‡ßã‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ‡¶® ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®:</label>
        <textarea id="input-text" rows="6" class="w-full text-input" placeholder="‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶ï‡ßã‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ‡¶® ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®..."></textarea>
      </div>

      <!-- Button -->
      <div class="text-center mb-10">
        <button id="translate-btn" class="btn-translate text-white font-bold py-3 px-10 rounded-full text-lg">
          ‡¶Ö‡¶®‡ßÅ‡¶¨‡¶æ‡¶¶ ‡¶ï‡¶∞‡ßÅ‡¶® üåê
        </button>
      </div>

      <!-- Outputs -->
      <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
        <div>
          <h2 id="translation-title" class="text-xl font-semibold text-gray-200 mb-3">‡¶Ö‡¶®‡ßÅ‡¶¨‡¶æ‡¶¶ (‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ ‡¶ì English):</h2>
          <div id="translation-output" class="output-box"></div>
        </div>
        <div>
          <h2 id="pronunciation-title" class="text-xl font-semibold text-gray-200 mb-3">‡¶â‡¶ö‡ßç‡¶ö‡¶æ‡¶∞‡¶£ (‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ):</h2>
          <div id="pronunciation-output" class="output-box"></div>
        </div>
      </div>
    </main>
  </div>

    <script>
        const translateBtn = document.getElementById('translate-btn');
        const languageSelect = document.getElementById('language-select');
        const inputText = document.getElementById('input-text');
        const inputLabel = document.getElementById('input-label');
        const translationOutput = document.getElementById('translation-output');
        const pronunciationOutput = document.getElementById('pronunciation-output');
        const translationTitle = document.getElementById('translation-title');
        const pronunciationTitle = document.getElementById('pronunciation-title');

        languageSelect.addEventListener('change', () => {
            const mode = languageSelect.value;
            if (mode === 'ko-bn') {
                inputLabel.textContent = '‡¶ï‡ßã‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ‡¶® ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®:';
                inputText.placeholder = '‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶ï‡ßã‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ‡¶® ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®...';
                translationTitle.textContent = '‡¶Ö‡¶®‡ßÅ‡¶¨‡¶æ‡¶¶ (‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ ‡¶ì English):';
                pronunciationTitle.textContent = '‡¶â‡¶ö‡ßç‡¶ö‡¶æ‡¶∞‡¶£ (‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ):';
                inputText.value = '';
                translationOutput.textContent = '';
                pronunciationOutput.textContent = '';
            } else {
                inputLabel.textContent = '‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®:';
                inputText.placeholder = '‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®...';
                translationTitle.textContent = '‡¶Ö‡¶®‡ßÅ‡¶¨‡¶æ‡¶¶ (‡¶ï‡ßã‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ‡¶®):';
                pronunciationTitle.textContent = '‡¶â‡¶ö‡ßç‡¶ö‡¶æ‡¶∞‡¶£ (‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ):';
                inputText.value = '';
                translationOutput.textContent = '';
                pronunciationOutput.textContent = '';
            }
        });

        translateBtn.addEventListener('click', async () => {
            const text = inputText.value;
            if (!text.trim()) return;

            const mode = languageSelect.value;
            
            // Disable button and show loading states
            translateBtn.disabled = true;
            translateBtn.textContent = '‡¶Ö‡¶®‡ßÅ‡¶¨‡¶æ‡¶¶ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...';
            translationOutput.textContent = '‡¶Ö‡¶®‡ßÅ‡¶¨‡¶æ‡¶¶ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá.‡¶¶‡ßü‡¶æ ‡¶ï‡¶∞‡ßá ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®...';
            pronunciationOutput.textContent = '‡¶â‡¶ö‡ßç‡¶ö‡¶æ‡¶∞‡¶£ ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...';
            
            if (mode === 'ko-bn') {
                // Get pronunciation first (client-side)
                pronunciationOutput.textContent = getPronunciationKoToBn(text);
                
                // Get translation (API call)
                const translation = await getAiTranslationKoToBn(text);
                translationOutput.textContent = translation;
            } else { // bn-ko mode
                const [translation, pronunciation] = await getAiTranslationBnToKo(text);
                translationOutput.textContent = translation;
                pronunciationOutput.textContent = pronunciation;
            }

            // Re-enable button
            translateBtn.disabled = false;
            translateBtn.textContent = '‡¶Ö‡¶®‡ßÅ‡¶¨‡¶æ‡¶¶ ‡¶ï‡¶∞‡ßÅ‡¶®';
        });

        // --- Functions for Korean to Bengali Translation ---
        async function getAiTranslationKoToBn(text) {
            const systemPrompt = `You are an expert translator for technical Korean to Bengali. Translate the user's text into a mix of Bengali and English, strictly following the rules below.

**Rules:**
1.  **Final Output Language:** The output must contain ONLY Bengali and English words. No Korean characters are allowed, except for the three specific words mentioned in Rule 4.
2.  **Specific Word Replacements:** You MUST replace these Korean words with their specified English or Bengali translation:
    * Ïó¥Ï≤òÎ¶¨ Ï†ÑÌõÑ -> JON/HOO
    * Ïó¥Ï≤òÎ¶¨ Ï†Ñ -> JON
    * Ïó¥Ï≤òÎ¶¨ ÌõÑ -> HOO
    * ÏÉÅÌòï -> UPR
    * ÌïòÌòï -> LWR
    * ÌëúÏãú -> ‡¶Æ‡¶æ‡¶∞‡ßç‡¶ï
    * ÎπÑÍµê -> ‡¶¨‡¶ø‡¶ó‡ßÅ
    * Ïùº -> ‡¶§‡¶æ‡¶∞‡¶ø‡¶ñ
    * Ï∂îÍ∞Ä -> ‡¶õ‡ßÇ‡¶ó‡¶æ
    * Ïãú -> ‡¶ü‡¶æ (when meaning 'hour' or 'time')
    * Ïû¨Î£å -> zero
    * ÏòÅÏó≠ -> BOUNDARY
    * Ïú§Í≥Ω -> ‡¶á‡¶Ø‡¶º‡¶Ç‡¶ó‡¶æ‡¶ï
    * ÏòÅÏó≠ -> BOUNDARY
    * Ïò¨Î†∏ÏäµÎãàÎã§ -> ‡¶Ü‡¶™‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡ßá‡¶õ‡¶ø
    * ÌòïÏÉÅ -> ‡¶π‡ßç‡¶Ø‡¶ø‡ßü‡¶Ç‡¶∏‡¶æ‡¶Ç
    * Í∞ÄÍ≥µ -> ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡¶æ
    * ÌõÑ -> ‡¶™‡¶∞
    * Ï∞∏Í≥† -> ‡¶õ‡¶æ‡¶Æ‡¶ó‡ßÅ
3.  **English in Korean Script:** Convert English words written in Hangul back to English. Examples: ÌîÑÎ°úÏÑ∏Ïä§ -> Process, Îç∞Ïù¥ÌÑ∞ -> Data.
4.  **Allowed Korean Words:** The ONLY Korean words allowed in the final output are: Ìô©ÏÇ≠, Ï§ëÏÇ≠, Ï†ïÏÇ≠, ÏûîÏÇ≠, Ï†ÑÏ≤¥.
5.  **Acronyms & Codes:** Keep English acronyms and codes as they are (e.g., UPR DIE, LWR DIE, OP30, NC, NCD, LR, RH).
6.  **General Translation:** Translate all other Korean text into natural-sounding Bengali.

Provide only the final translated text as your response, without any extra explanations.`;
            
            const apiKey = "AIzaSyAmSyH-IGhaHH-oZa4tMJ2e80x5ISj0zyw";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{ parts: [{ text: text }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status}`);
                }

                const result = await response.json();
                const candidate = result.candidates?.[0];

                if (candidate && candidate.content?.parts?.[0]?.text) {
                    return candidate.content.parts[0].text;
                } else {
                    console.error("Invalid API response:", result);
                    return "‡¶¶‡ßÅ‡¶É‡¶ñ‡¶ø‡¶§, ‡¶è‡¶ï‡¶ü‡¶ø ‡¶Ö‡¶™‡ßç‡¶∞‡¶§‡ßç‡¶Ø‡¶æ‡¶∂‡¶ø‡¶§ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§";
                }
            } catch (error) {
                console.error("Translation error:", error);
                return "‡¶Ö‡¶®‡ßÅ‡¶¨‡¶æ‡¶¶ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶è‡¶ï‡¶ü‡¶ø ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø ‡¶ò‡¶ü‡ßá‡¶õ‡ßá‡•§ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶á‡¶®‡ßç‡¶ü‡¶æ‡¶∞‡¶®‡ßá‡¶ü ‡¶∏‡¶Ç‡¶Ø‡ßã‡¶ó ‡¶™‡¶∞‡ßÄ‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§";
            }
        }
        
        function getPronunciationKoToBn(text) {
            const pronunciationMap = new Map([
                ["Ïó¥Ï≤òÎ¶¨ Ï†ÑÌõÑ", "‡¶á‡¶ì‡¶≤‡¶õ‡¶∞‡¶ø ‡¶ú‡¶®‡¶π‡ßÅ"], ["Ïó¥Ï≤òÎ¶¨ Ï†Ñ", "‡¶á‡¶ì‡¶≤‡¶õ‡¶∞‡¶ø ‡¶ú‡¶®"], ["Ïó¥Ï≤òÎ¶¨ ÌõÑ", "‡¶á‡¶ì‡¶≤‡¶õ‡¶∞‡¶ø ‡¶π‡ßÅ"],
                ["ÌîÑÎ°úÏÑ∏Ïä§", "‡¶™‡ßç‡¶∞‡ßã‡¶∏‡ßá‡¶∏"], ["Îç∞Ïù¥ÌÑ∞", "‡¶¶‡ßá‡¶§‡¶æ"], ["ÏÉÅÌòï", "‡¶∏‡¶æ‡¶Ç-‡¶π‡¶ø‡¶Ø‡¶º‡¶Ç"], ["ÌïòÌòï", "‡¶π‡¶æ-‡¶π‡¶ø‡¶Ø‡¶º‡¶Ç"],
                ["ÌëúÏãú", "‡¶´‡¶ø‡¶Ø‡¶º‡ßã‡¶∂‡¶ø"], ["‡¶¨‡¶øÍµê", "‡¶¨‡¶ø‡¶ó‡¶ø‡¶Ø‡¶º‡ßã"], ["Ïùº", "‡¶á‡¶≤"], ["Ï∂îÍ∞Ä", "‡¶õ‡ßÅ‡¶ó‡¶æ"],
                ["Ïãú", "‡¶∂‡¶ø"], ["Ïû¨Î£å", "‡¶ú‡ßá‡¶∞‡¶ø‡¶Ø‡¶º‡ßã"], ["ÏòÅÏó≠", "‡¶á‡¶Ø‡¶º‡¶Ç‡¶á‡¶Ø‡¶º‡ßã‡¶ó"], ["Ïú§Í≥Ω", "‡¶á‡¶â‡¶®‡¶ó‡ßÅ‡¶Ø‡¶º‡¶æ‡¶ï"],
                ["Ìô©ÏÇ≠", "‡¶π‡ßã‡¶Ø‡¶º‡¶æ‡¶Ç‡¶∏‡¶æ‡¶ï"], ["Ï§ëÏÇ≠", "‡¶ú‡ßÅ‡¶Ç‡¶∏‡¶æ‡¶ï"], ["Ï†ïÏÇ≠", "‡¶ú‡¶Ç‡¶∏‡¶æ‡¶ï"]
            ]);
            
            let simplePronunciation = koreanToBanglaPronunciation(text);
            pronunciationMap.forEach((bangla, korean) => {
                const regex = new RegExp(koreanToBanglaPronunciation(korean), "g");
                simplePronunciation = simplePronunciation.replace(regex, bangla);
            });

            const allowedCharsRegex = /[^\u0980-\u09FFa-zA-Z0-9\s-]/g;
            return simplePronunciation.replace(allowedCharsRegex, '');
        }

        // Generic function to convert any Korean text to Bangla pronunciation (simplified)
        function koreanToBanglaPronunciation(text) {
            const b_initials = ['‡¶ó', '‡¶ï', '‡¶®', '‡¶¶', '‡¶§', '‡¶∞', '‡¶Æ', '‡¶¨', '‡¶™', '‡¶∏', '‡¶∏', '', '‡¶ú', '‡¶ö', '‡¶õ', '‡¶ñ', '‡¶•', '‡¶´', '‡¶π'];
            const b_vowels_full = ['‡¶Ü', 'Ïï†', '‡¶á‡¶Ø‡¶º‡¶æ', '‡¶á‡¶Ø‡¶º‡ßá', '‡¶Ö', '‡¶è', '‡¶á‡¶Ø‡¶º‡ßá', '‡¶á‡¶Ø‡¶º‡ßá', '‡¶ì', '‡¶ì‡¶Ø‡¶º‡¶æ', '‡¶ì‡¶Ø‡¶º‡ßá', '‡¶ì‡¶Ø‡¶º‡ßá', '‡¶á‡¶Ø‡¶º‡ßã', '‡¶â', '‡¶ì', '‡¶ì‡¶Ø‡¶º‡ßá', '‡¶â‡¶á', '‡¶á‡¶Ø‡¶º‡ßÅ', '‡¶â', '‡¶â‡¶á', '‡¶á'];
            const b_medials_diacritic = ['‡¶æ', '‡ßá', '‡ßç‡¶Ø‡¶æ', '‡ßç‡¶Ø‡ßá', '', '‡ßá', '‡ßç‡¶Ø‡ßá', '‡ßç‡¶Ø‡ßá', '‡ßã', '‡ßã‡¶Ø‡¶º‡¶æ', '‡ßã‡¶Ø‡¶º‡ßá', '‡ßã‡¶Ø‡¶º‡ßá', '‡ßç‡¶Ø‡ßã', '‡ßÅ', '‡ßÅ‡¶Ø‡¶º‡ßã', '‡ßÅ‡¶Ø‡¶º‡ßá', '‡ßÅ‡¶á', '‡ßç‡¶Ø‡ßÅ', '‡ßÅ', '‡ßÅ‡¶á', '‡¶ø'];
            const b_finals = ['', '‡¶ï‡ßç', '‡¶ï‡ßç', '‡¶ï‡ßç', '‡¶®‡ßç', '‡¶®‡ßç', '‡¶®‡ßç', '‡¶§‡ßç', '‡¶≤‡ßç', '‡¶ï‡ßç', '‡¶Æ‡ßç', '‡¶≤‡ßç', '‡¶≤‡ßç', '‡¶≤‡ßç', '‡¶™‡ßç', '‡¶≤‡ßç', '‡¶Æ‡ßç', '‡¶™‡ßç', '‡¶™‡ßç', '‡¶§‡ßç', '‡¶§‡ßç', '‡¶Ç', '‡¶§‡ßç', '‡¶§‡ßç', '‡¶ï‡ßç', '‡¶§‡ßç', '‡¶™‡ßç', '‡¶§‡ßç'];

            let result = '';
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const char_code = char.charCodeAt(0);

                if (char_code >= 0xAC00 && char_code <= 0xD7A3) { // Check if it is a Hangul syllable
                    const syllable_index = char_code - 0xAC00;
                    const initial_index = Math.floor(syllable_index / 588);
                    const medial_index = Math.floor((syllable_index % 588) / 28);
                    const final_index = syllable_index % 28;

                    let syllable_pronunciation;

                    if (initial_index === 11) { // Syllable starts with '„Öá' (silent initial)
                        syllable_pronunciation = b_vowels_full[medial_index];
                    } else {
                        syllable_pronunciation = b_initials[initial_index];
                        if (b_medials_diacritic[medial_index]) {
                            syllable_pronunciation += b_medials_diacritic[medial_index];
                        }
                    }
                    if (final_index > 0) {
                        syllable_pronunciation += b_finals[final_index];
                    }
                    result += syllable_pronunciation;
                } else { // Not a Hangul syllable, append as is
                    result += char;
                }
            }
            return result;
        }

        // --- Functions for Bengali to Korean Translation ---
        async function getAiTranslationBnToKo(text) {
            const systemPrompt = `You are an expert translator. The user will provide Bengali or English text, and you must translate it into Korean (Hangul).

**Rules:**
1.  **Target Language:** The output must be entirely in Korean (Hangul).
2.  **Specific Word Replacements:** Translate the following Bengali/English terms into their specified Korean counterparts.
    * UPR -> ÏÉÅÌòï
    * LWR -> ÌïòÌòï
    * ‡¶Æ‡¶æ‡¶∞‡ßç‡¶ï -> ÌëúÏãú
    * ‡¶¨‡¶ø‡¶ó‡ßÅ -> ÎπÑÍµê
    * ‡¶§‡¶æ‡¶∞‡¶ø‡¶ñ -> Ïùº
    * ‡¶õ‡ßÇ‡¶ó‡¶æ -> Ï∂îÍ∞Ä
    * ‡¶ü‡¶æ (when referring to time) -> Ïãú
    * zero -> Ïû¨Î£å
    * JON/HOO -> Ïó¥Ï≤òÎ¶¨ Ï†ÑÌõÑ
    * JON -> Ïó¥Ï≤òÎ¶¨ Ï†Ñ
    * HOO -> Ïó¥Ï≤òÎ¶¨ ÌõÑ
    * BOUNDARY -> ÏòÅÏó≠
    * ‡¶á‡¶Ø‡¶º‡¶Ç‡¶ó‡¶æ‡¶ï -> Ïú§Í≥Ω
3.  **Allowed Korean Words:** You are allowed to use the following specific Korean words as they are, without translating them back to Bengali: Ìô©ÏÇ≠, Ï§ëÏÇ≠, Ï†ïÏÇ≠.
4.  **General Translation:** Translate all other Bengali and English text into natural-sounding Korean.
5.  **Pronunciation:** After the Korean translation, add a new line and provide the Bengali pronunciation of the translated Korean text. Do not provide a Bengali translation of the text.
6.  **Acronyms & Codes:** Keep English acronyms and codes as they are (e.g., UPR DIE, LWR DIE, OP30, NC, NCD, LR, RH).

Provide only the Korean translation and its Bengali pronunciation as the response, separated by a newline, without any extra explanations.`;
            
            const apiKey = "AIzaSyAmSyH-IGhaHH-oZa4tMJ2e80x5ISj0zyw";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const payload = {
                contents: [{ parts: [{ text: text }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status}`);
                }
                const result = await response.json();
                const candidate = result.candidates?.[0];
                if (candidate && candidate.content?.parts?.[0]?.text) {
                    const [translation, pronunciation] = candidate.content.parts[0].text.split('\n');
                    return [translation, pronunciation];
                } else {
                    console.error("Invalid API response:", result);
                    return ["‡¶¶‡ßÅ‡¶É‡¶ñ‡¶ø‡¶§, ‡¶è‡¶ï‡¶ü‡¶ø ‡¶Ö‡¶™‡ßç‡¶∞‡¶§‡ßç‡¶Ø‡¶æ‡¶∂‡¶ø‡¶§ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§", ""];
                }
            } catch (error) {
                console.error("Translation error:", error);
                return ["‡¶Ö‡¶®‡ßÅ‡¶¨‡¶æ‡¶¶ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶è‡¶ï‡¶ü‡¶ø ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø ‡¶ò‡¶ü‡ßá‡¶õ‡ßá‡•§ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶á‡¶®‡ßç‡¶ü‡¶æ‡¶∞‡¶®‡ßá‡¶ü ‡¶∏‡¶Ç‡¶Ø‡ßã‡¶ó ‡¶™‡¶∞‡ßÄ‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§", ""];
            }
        }
    </script>
</body>
</html>



